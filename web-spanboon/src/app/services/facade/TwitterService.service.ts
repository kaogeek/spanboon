/*
 * @license Spanboon Platform v0.1
 * (c) 2020-2021 KaoGeek. http://kaogeek.dev
 * License: MIT. https://opensource.org/licenses/MIT
 * Author:  p-nattawadee <nattawdee.l@absolute.co.th>,  Chanachai-Pansailom <chanachai.p@absolute.co.th> , Americaso <treerayuth.o@absolute.co.th >
 */

import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import * as oauthSignature from 'oauth-signature';
import { environment } from '../../../environments/environment';

const twitterObj = {
    consumerKey: environment.consumerKeyTwitter,
    consumerSecret: environment.consumerSecretTwitter,
    accessToken: environment.accessTokenTwitter,
    accessTokenSecret: environment.accessTokenSecretTwitter,
};

@Injectable()
export class TwitterService {

    protected http: HttpClient;
    protected oauthToken: string;
    protected oauthTokenSecret: string;
    protected oauthCallbackConfirm: string;

    constructor(http: HttpClient) {
        this.http = http;
    }

    /*
    * https://api.twitter.com/oauth/request_token 
    */
    // 1. request for token 
    public requestToken(callback? : any): Promise<any> {
        const urlCallback = '?oauth_callback=' + encodeURIComponent('https://spanboon.io:4200/'+callback);
        const url: string = 'https://cors-anywhere.herokuapp.com/https://api.twitter.com/oauth/request_token' + urlCallback;
        const twitterUrl: string = 'https://api.twitter.com/oauth/request_token';
        const body: any = {};
        const oauth_timestamp = Math.floor((new Date()).getTime() / 1000).toString();
        const oauth_nonce = this.genNonce(); // unique token your application should generate for each unique request 
        // generate oauth
        const parameters = {  
            oauth_consumer_key: twitterObj.consumerKey,
            oauth_token: twitterObj.accessToken,
            oauth_signature_method: 'HMAC-SHA1',
            oauth_timestamp: oauth_timestamp,
            oauth_nonce: oauth_nonce,
            oauth_callback: 'https://spanboon.io:4200/'+callback, // this call back must in developer callback list in twitter dev page.
            oauth_version: '1.0'
        }; 
        
        const consumerSecret = twitterObj.consumerSecret;
        const tokenSecret = twitterObj.accessTokenSecret;
        const options = {}; 
        const oauth_signature = oauthSignature.generate('POST', twitterUrl, parameters, consumerSecret, tokenSecret, options); // a value which is generated by running all of the other request parameters and two secret values through a signing algorithm

        let headers = new HttpHeaders({
            'Authorization': 'OAuth oauth_consumer_key="' + twitterObj.consumerKey + '",oauth_token="' + twitterObj.accessToken + '",oauth_signature_method="HMAC-SHA1",oauth_timestamp="' + oauth_timestamp + '",oauth_nonce="' + oauth_nonce + '",oauth_version="1.0",oauth_callback="' + encodeURIComponent('https://spanboon.io:4200/'+callback) + '", oauth_signature="' + oauth_signature + '"',
        });

        let httpOptions: any = {
            headers: headers,
            responseType: 'text'
        }; 

        return new Promise((resolve, reject) => {
            this.http.post(url, body, httpOptions).toPromise().then((result: any) => {
                resolve(result);
            }).catch((error) => {
                reject(error);
            });
        });
    }

    public getAcessToKen(accessTokenLink: string, httpOptions) {
        return new Promise((resolve, reject) => {
            this.http.get('https://cors-anywhere.herokuapp.com/' + accessTokenLink, httpOptions).toPromise().then((result: any) => {
                resolve(result);
            }).catch((error) => {
                console.log(error);
                reject(error);
            });
        });
    }

    /*
   * https://api.twitter.com/1.1/account/verify_credentials.json
   */
    // 1. token for information
    public accountVerify(accessToKen: string, tokenSecret: string): Promise<any> {
        const url: string = 'https://cors-anywhere.herokuapp.com/https://api.twitter.com/1.1/account/verify_credentials.json';
        const twitterUrl: string = 'https://api.twitter.com/1.1/account/verify_credentials.json';
        const body: any = {};
        const oauth_timestamp = Math.floor((new Date()).getTime() / 1000).toString();
        const oauth_nonce = this.genNonce(); // unique token your application should generate for each unique request

        // generate oauth
        const parameters = {
            oauth_consumer_key: twitterObj.consumerKey,
            oauth_token: accessToKen,
            oauth_signature_method: 'HMAC-SHA1',
            oauth_timestamp: oauth_timestamp,
            oauth_nonce: oauth_nonce,
            oauth_version: '1.0'
        };
        const consumerSecret = twitterObj.consumerSecret;
        const token = tokenSecret;
        const options = {};
        const oauth_signature = oauthSignature.generate('GET', twitterUrl, parameters, consumerSecret, token, options); // a value which is generated by running all of the other request parameters and two secret values through a signing algorithm

        let headers = new HttpHeaders({
            'Authorization': 'OAuth oauth_consumer_key="' + twitterObj.consumerKey + '",oauth_token="' + accessToKen + '",oauth_signature_method="HMAC-SHA1",oauth_timestamp="' + oauth_timestamp + '",oauth_nonce="' + oauth_nonce + '",oauth_version="1.0",oauth_signature="' + oauth_signature + '"',
        });

        let httpOptions: any = {
            headers: headers,
            responseType: 'json'
        };

        return new Promise((resolve, reject) => {
            this.http.get(url, httpOptions).toPromise().then((result: any) => {
                resolve(result);
            }).catch((error) => {
                reject(error);
            });
        });
    }

    public genNonce() {
        const charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._~'
        const result = [];
        window.crypto.getRandomValues(new Uint8Array(32)).forEach(c =>
            result.push(charset[c % charset.length]));
        return result.join('');
    }

}
